#!/usr/bin/env python3
import streamlit as st
import pandas as pd
import requests
import plotly.express as px
import time
import json
import os
import tempfile
import logging
from datetime import datetime, timedelta

# --- LOG ---
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger("dashboard-app")

# --- STREAMLIT PAGE CONFIG ---
st.set_page_config(
    page_title="Mitragliere Terminal V2",
    layout="wide",
    page_icon="üí£",
    initial_sidebar_state="collapsed"
)

# --- PATH FILE STORICO (vicino a questo file) ---
BASE_DIR = os.path.dirname(os.path.abspath(__file__))
HISTORY_FILE = os.getenv("MITRAGLIERE_HISTORY_FILE", os.path.join(BASE_DIR, "equity_history.json"))
START_DATE = os.getenv("MITRAGLIERE_START_DATE", "2025-11-30")
AUTO_REFRESH = os.getenv("MITRAGLIERE_AUTO_REFRESH", "1") == "1"

# --- URLS (override via env se necessario) ---
URLS = {
    "manager": os.getenv("MITRAGLIERE_MANAGER_URL", "http://position-manager-agent:8000"),
    "sentiment": os.getenv("MITRAGLIERE_SENTIMENT_URL", "http://news-sentiment-agent:8000"),
    "technical": os.getenv("MITRAGLIERE_TECH_URL", "http://technical-analyzer-agent:8000")
}

# --- CSS ---
st.markdown("""
    <style>
    @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Roboto+Mono:wght@400;700&display=swap');
    .stApp { background-color: #050505; background-image: radial-gradient(circle at 50% 50%, #1a1a1a 0%, #000000 100%); color: #e0e0e0; font-family: 'Roboto Mono', monospace; }
    h1,h2,h3 { font-family: 'Orbitron', sans-serif; text-transform: uppercase; letter-spacing: 2px; color:#00ff88; text-shadow:0 0 10px rgba(0,255,136,0.5); }
    div[data-testid="stMetric"] { background-color: rgba(20,20,20,0.8); border: 1px solid #333; border-left:5px solid #00ff88; padding:15px; border-radius:8px; box-shadow:0 0 15px rgba(0,255,136,0.1); transition: transform 0.2s; }
    div[data-testid="stMetric"]:hover { transform: scale(1.02); border-left:5px solid #00ccff; box-shadow:0 0 20px rgba(0,204,255,0.2); }
    div[data-testid="stMetricValue"] { font-family:'Orbitron',sans-serif; font-size:24px !important; color:#fff !important; }
    .dataframe { font-family:'Roboto Mono', monospace; background-color: rgba(255,255,255,0.05); }
    .console-log { background-color:#000; border:1px solid #333; color:#0f0; font-family:'Courier New', monospace; padding:10px; height:300px; overflow-y:scroll; font-size:12px; border-radius:5px; }
    .stButton>button { background-color:#000; color:#00ff88; border:1px solid #00ff88; font-family:'Orbitron',sans-serif; }
    .stButton>button:hover { background-color:#00ff88; color:#000; box-shadow:0 0 10px #00ff88; }
    .news-card { background: rgba(255,255,255,0.05); border-left:3px solid #ffcc00; padding:10px; margin-bottom:5px; font-size:0.9rem; }
    .closed-list { background: rgba(255,255,255,0.03); border:1px solid #333; padding:10px; height:360px; overflow-y:auto; border-radius:6px; }
    .closed-item { border-bottom:1px dashed #444; padding:8px 0; }
    </style>
""", unsafe_allow_html=True)

# --- HTTP SESSION ---
session = requests.Session()
DEFAULT_TIMEOUT = 2.0

def fetch(url, endpoint, default=None, timeout=DEFAULT_TIMEOUT):
    try:
        r = session.get(f"{url}{endpoint}", timeout=timeout)
        if r.status_code == 200:
            return r.json()
        else:
            logger.warning("Fetch %s returned %s", endpoint, r.status_code)
    except requests.RequestException as e:
        logger.warning("Fetch %s failed: %s", endpoint, e)
    return default

def load_local_history():
    if os.path.exists(HISTORY_FILE):
        try:
            with open(HISTORY_FILE, "r") as f:
                data = json.load(f)
                if isinstance(data, list):
                    data.sort(key=lambda x: x.get("time", ""))
                    return data
        except Exception as e:
            logger.exception("Errore caricamento history: %s", e)
    return []

def save_local_history(new_data):
    if not new_data:
        return load_local_history()
    history = load_local_history()
    existing_ts = {str(h.get('time')) for h in history if h.get('time') is not None}
    changed = False
    for item in new_data:
        t = item.get('time')
        if t and str(t) not in existing_ts:
            history.append(item)
            existing_ts.add(str(t))
            changed = True
    if changed:
        history.sort(key=lambda x: x.get('time', ''))
        to_write = history[-1000:]
        try:
            dirpath = os.path.dirname(HISTORY_FILE) or BASE_DIR
            with tempfile.NamedTemporaryFile('w', delete=False, dir=dirpath) as tf:
                json.dump(to_write, tf)
                tempname = tf.name
            os.replace(tempname, HISTORY_FILE)
            logger.info("History salvata (%d punti)", len(to_write))
        except Exception as e:
            logger.exception("Errore salvataggio history: %s", e)
    return history

def translate_action(text):
    if not text: return ""
    text = text.replace("Opening", "APERTURA").replace("OPENED", "APERTO")
    text = text.replace("CLOSED", "CHIUSO").replace("Moving SL", "SPOSTAMENTO SL")
    text = text.replace("Break Even", "PAREGGIO").replace("Rizzo", "Mitragliere")
    text = text.replace("to", "a").replace("with", "con").replace("Buy", "ACQUISTO").replace("Sell", "VENDITA")
    text = text.replace("HOLD", "ATTESA").replace("NO TRADES", "NESSUN TRADE")
    return text

# NOTE: rimozione pulsanti "CHIUDI" (non esiste close action qui)

def fetch_closed_positions(manager_url):
    # prova endpoint esplicito, fallback a parsing logs
    closed = fetch(manager_url, "/get_closed_positions", default=None)
    if closed:
        return closed
    # fallback: chiediamo i logs e filtriamo
    logs = fetch(manager_url, "/management_logs", default=[])
    closed_from_logs = []
    for l in (logs or []):
        act = l.get('action','')
        if 'CLOSED' in act or 'closed' in act or 'CLOSE' in act:
            closed_from_logs.append({
                "symbol": l.get('pair') or l.get('symbol') or "",
                "pnl": l.get('pnl') or l.get('profit') or 0,
                "time": l.get('time') or l.get('timestamp') or "",
                "side": l.get('side') or "",
                "detail": act
            })
    return closed_from_logs

def fetch_coingecko_news(per_page=20):
    try:
        url = f"https://api.coingecko.com/api/v3/status_updates?per_page={per_page}"
        r = session.get(url, timeout=5)
        if r.status_code == 200:
            data = r.json()
            return data.get("status_updates", []) if isinstance(data, dict) else []
    except Exception as e:
        logger.warning("CoinGecko news fetch error: %s", e)
    return []

# --- LOAD DATA ---
wallet = fetch(URLS['manager'], "/get_wallet_balance", {}) or {}
positions = fetch(URLS['manager'], "/get_open_positions", []) or []
logs = fetch(URLS['manager'], "/management_logs", []) or []
sent_data = fetch(URLS['sentiment'], "/global_sentiment", {}) or {}

raw_history = fetch(URLS['manager'], "/equity_history", []) or []
if raw_history:
    full_history = save_local_history(raw_history)
else:
    full_history = load_local_history()

# --- CALCOLI EVALUATION ---
try:
    balance = float(wallet.get("balance", 0.0) or 0.0)
except Exception:
    balance = 0.0
open_pnl = sum(float(p.get('pnl', 0) or 0) for p in positions)
equity = balance + open_pnl

# fees/exposure (come prima)
est_fees = 0.0
total_exposure = 0.0
for p in positions:
    try:
        size = float(p.get('size', 0) or 0)
        entry = float(p.get('entry_price', 0) or 0)
        size_usd = size * entry
        fees_pos = size_usd * 0.00055 * 2
        est_fees += fees_pos
        total_exposure += size_usd
    except Exception:
        continue

guardian_moves = len([l for l in logs if "Moving SL" in l.get('action', '')])
guardian_saved_est = guardian_moves * 15

# --- HEADER ---
c1, c2 = st.columns([3, 1])
with c1:
    st.title("ü¶Ö MITRAGLIERE TERMINAL V2")
    st.caption(f"System Online | Connected to Matrix: 207.154.212.99 | Start: {START_DATE}")
with c2:
    if st.button("üîÑ REFRESH DATA", use_container_width=True):
        st.experimental_rerun()

st.markdown("---")

# --- KPI ROW ---
k1, k2, k3, k4, k5 = st.columns(5)
k1.metric("üí∞ SALDO WALLET", f"${balance:,.2f}", delta_color="off")
k2.metric("üìà EQUITY NETTA", f"${equity:,.2f}", delta=f"{open_pnl:+.2f} PnL Aperto")
k3.metric("üõ°Ô∏è GUARDIAN SAVES", f"{guardian_moves}", delta=f"~${guardian_saved_est} Salvati")
k4.metric("üí∏ COMMIS. STIMATE", f"-${est_fees:.2f}", help="Costo stimato apertura/chiusura posizioni correnti")
k5.metric("üí£ POSIZIONI", f"{len(positions)}", f"${total_exposure:,.0f} Esposizione")

# --- MAIN & SIDE ---
col_main, col_side = st.columns([2, 1])

with col_main:
    st.subheader("üìä ANDAMENTO CONTO (baseline 48h)")
    # costruzione della serie equity che parte da 48 ore fa
    now = datetime.utcnow()
    start_dt = now - timedelta(hours=48)

    # parse full_history in DataFrame se possibile
    df_equity = None
    try:
        if full_history:
            df_equity = pd.DataFrame(full_history)
            if 'time' in df_equity.columns:
                df_equity['time_parsed'] = pd.to_datetime(df_equity['time'], utc=True, errors='coerce')
            else:
                df_equity['time_parsed'] = pd.NaT
            if 'equity' in df_equity.columns:
                df_equity['equity'] = pd.to_numeric(df_equity['equity'], errors='coerce')
        else:
            df_equity = pd.DataFrame(columns=['time','equity','time_parsed'])
    except Exception as e:
        logger.exception("Errore trasformazione full_history: %s", e)
        df_equity = pd.DataFrame(columns=['time','equity','time_parsed'])

    # cerca punto pi√π recente <= start_dt
    baseline_value = None
    try:
        candidates = df_equity[df_equity['time_parsed'].notna()]
        if not candidates.empty:
            before = candidates[candidates['time_parsed'] <= pd.Timestamp(start_dt, tz='UTC')]
            if not before.empty:
                # prendiamo l'ultimo valore disponibile prima o uguale a start_dt
                baseline_value = float(before.sort_values('time_parsed').iloc[-1]['equity'])
    except Exception:
        baseline_value = None

    if baseline_value is None:
        # fallback: usiamo il balance corrente come baseline se non troviamo storico a 48h
        baseline_value = balance

    # costruzione lista punti: baseline a start_dt, poi punti storici >= start_dt, poi punto corrente now
    points = []
    points.append({'time_parsed': pd.Timestamp(start_dt, tz='UTC'), 'equity': baseline_value, 'label': 'baseline'})
    try:
        if not df_equity.empty:
            recent = df_equity[df_equity['time_parsed'] >= pd.Timestamp(start_dt, tz='UTC')].copy()
            if not recent.empty:
                recent = recent.sort_values('time_parsed')
                for _, r in recent.iterrows():
                    points.append({'time_parsed': r['time_parsed'], 'equity': float(r['equity']) if pd.notna(r['equity']) else None, 'label': 'history'})
    except Exception:
        pass
    # aggiungiamo punto attuale
    points.append({'time_parsed': pd.Timestamp(now, tz='UTC'), 'equity': equity, 'label': 'now'})

    df_plot = pd.DataFrame(points)
    # assicurati ordinamento
    df_plot = df_plot.sort_values('time_parsed')

    try:
        fig = px.area(df_plot, x='time_parsed', y='equity', template="plotly_dark", labels={'time_parsed': 'time', 'equity': 'Equity'})
        fig.update_traces(line_color='#00ff88', fillcolor='rgba(0, 255, 136, 0.12)')
        fig.update_layout(height=380, margin=dict(l=10,r=10,t=10,b=10), paper_bgcolor='rgba(0,0,0,0)', plot_bgcolor='rgba(0,0,0,0)')
        st.plotly_chart(fig, use_container_width=True)
    except Exception as e:
        logger.exception("Errore creazione grafico: %s", e)
        st.info("Impossibile disegnare il grafico in questo momento.")

    st.subheader("‚ö° POSIZIONI ATTIVE")
    # Rimuoviamo i pulsanti "CHIUDI": visualizziamo solo le info
    if positions:
        df_pos = pd.DataFrame(positions)
        for _, row in df_pos.iterrows():
            with st.container():
                c_sym, c_lev, c_pnl, c_sl = st.columns([1.5, 1, 1.5, 1.5])
                sym = row.get('symbol', '')
                pnl = float(row.get('pnl', 0) or 0)
                entry = float(row.get('entry_price', 0) or 0)
                sl = float(row.get('stop_loss', 0) or 0)
                dist_sl_pct = ((entry - sl) / entry) * 100 if sl > 0 and entry else 0
                pnl_color = "#00ff88" if pnl >= 0 else "#ff4444"
                c_sym.markdown(f"**{sym}**")
                c_sym.caption(f"Ingresso: ${entry:,.2f}")
                c_lev.markdown(f"x{float(row.get('leverage',1)):.0f}")
                c_lev.caption(row.get('side', ''))
                c_pnl.markdown(f\"\"\"<span style='color:{pnl_color}; font-size:1.2rem; font-weight:bold'>${pnl:+.2f}</span>\"\"\", unsafe_allow_html=True)
                sl_status = "üîí BE (Risk Free)" if (row.get('side') == "Buy" and sl > entry) or (row.get('side') == "Sell" and sl < entry) else f"-{abs(dist_sl_pct):.2f}%"
                if sl == 0:
                    sl_status = "‚ö†Ô∏è NO SL"
                c_sl.markdown(f"SL: ${sl:,.2f}")
                c_sl.caption(f"{sl_status}")
                st.markdown("<hr style='margin: 5px 0; border-color: #333'>", unsafe_allow_html=True)
    else:
        st.markdown("""<div style='padding:30px; text-align:center; border:1px dashed #444; border-radius:10px;'>
            <h3 style='color:#666'>NESSUN BERSAGLIO INGAGGIATO</h3>
            <p>Il radar √® attivo. In attesa di occasioni tattiche.</p>
            </div>""", unsafe_allow_html=True)

with col_side:
    st.subheader("üß† INTELLIGENCE ROOM")
    score = int(sent_data.get("score", 50) or 50)
    label = sent_data.get("label", "Neutrale")
    st.markdown(f"**Sentiment Mercato:** {label} ({score}/100)")
    st.progress(score / 100)
    st.markdown("**ü§ñ Ultimo Ordine Master:**")
    ai_logs = [l for l in logs if "EXEC" in l.get('action', '')] if logs else []
    if ai_logs:
        last = ai_logs[0]
        st.success(f"{translate_action(last.get('action',''))}")
    else:
        st.text("Nessun ordine recente.")

    st.markdown("---")
    st.subheader("üì∞ Ultime Notizie (CoinGecko)")
    news = fetch_coingecko_news(20)
    if news:
        for n in news:
            title = n.get('user') or n.get('project') or n.get('title') or n.get('description','')[:80]
            desc = n.get('description','')
            created = n.get('created_at') or n.get('created_at') or ""
            url = n.get('project_url') or n.get('url') or ""
            html = f"<div class='news-card'><b>{title}</b><br><small style='color:#999'>{created}</small><p>{desc}</p>"
            if url:
                html += f"<a href='{url}' target='_blank' rel='noreferrer' style='color:#ffcc00'>Link</a>"
            html += "</div>"
            st.markdown(html, unsafe_allow_html=True)
    else:
        st.text("Nessuna news disponibile da CoinGecko in questo momento.")

    st.markdown("---")
    st.subheader("üóÇÔ∏è Ultime 20 Posizioni Chiuse")
    closed = fetch_closed_positions(URLS['manager'])
    # Ordini chiusi: ordina per time decrescente e prendi 20
    closed_list = []
    for c in (closed or []):
        time_s = c.get('time') or c.get('closed_at') or c.get('timestamp') or ""
        try:
            t_parsed = pd.to_datetime(time_s, utc=True, errors='coerce')
        except Exception:
            t_parsed = None
        closed_list.append({
            "symbol": c.get('symbol') or c.get('pair') or "",
            "pnl": float(c.get('pnl') or c.get('profit') or 0),
            "time": t_parsed,
            "side": c.get('side') or "",
            "detail": c.get('detail') or ""
        })
    closed_list = sorted(closed_list, key=lambda x: x['time'] or pd.Timestamp(0), reverse=True)[:20]

    if closed_list:
        html = "<div class='closed-list'>"
        for it in closed_list:
            tstr = it['time'].strftime('%Y-%m-%d %H:%M:%S UTC') if it['time'] is not None else ''
            color = "#00ff88" if it['pnl'] >= 0 else "#ff4444"
            html += f"<div class='closed-item'><b>{it['symbol']}</b> <small style='color:#999'>[{tstr}]</small><br>Side: {it['side']} ‚Äî P&L: <span style='color:{color}'>${it['pnl']:+.2f}</span><br><small style='color:#999'>{it['detail']}</small></div>"
        html += "</div>"
        st.markdown(html, unsafe_allow_html=True)
    else:
        st.text("Nessuna posizione chiusa disponibile (endpoint manager).")

# --- LOG ---
st.markdown("---")
st.subheader("üìú LOG DI MISSIONE (LIVE)")
log_html = "<div class='console-log'>"
if logs:
    for l in logs[:30]:
        color = "#00ff88" if l.get('status') == 'success' else ("#ffaa00" if l.get('status') == 'warning' else "#00ccff")
        pair = l.get('pair', '') or l.get('symbol','')
        time_s = l.get('time', '')
        line = f"<span style='color:#666'>[{time_s}]</span> <span style='color:{color}'><b>{pair}</b></span>: {translate_action(l.get('action'))}<br>"
        log_html += line
else:
    log_html += "In attesa di log dal sistema..."
log_html += "</div>"
st.markdown(log_html, unsafe_allow_html=True)

# --- AUTO REFRESH OPZIONALE ---
if AUTO_REFRESH:
    try:
        time.sleep(30)
        st.experimental_rerun()
    except Exception:
        logger.exception("Auto-refresh fallito")
